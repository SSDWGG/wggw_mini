"use strict";
(wx["webpackJsonp"] = wx["webpackJsonp"] || []).push([["vendors-node_modules_taro_weapp_prebundle_mini-ui_js"],{

/***/ "./node_modules/.taro/weapp/prebundle/mini-ui.js":
/*!*******************************************************!*\
  !*** ./node_modules/.taro/weapp/prebundle/mini-ui.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Drag": function() { return /* binding */ _sfc_main$2; },
/* harmony export */   "Navbar": function() { return /* binding */ index; },
/* harmony export */   "Scroll": function() { return /* binding */ _sfc_main; },
/* harmony export */   "Tabs": function() { return /* binding */ _sfc_main$1; }
/* harmony export */ });
/* harmony import */ var _chunk_4BR5KQZZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-4BR5KQZZ.js */ "./node_modules/.taro/weapp/prebundle/chunk-4BR5KQZZ.js");
/* harmony import */ var _chunk_44HY4TYC_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-44HY4TYC.js */ "./node_modules/.taro/weapp/prebundle/chunk-44HY4TYC.js");
/* harmony import */ var _chunk_I7JVLPJC_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-I7JVLPJC.js */ "./node_modules/.taro/weapp/prebundle/chunk-I7JVLPJC.js");
/* harmony import */ var _chunk_VCL4GLTP_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-VCL4GLTP.js */ "./node_modules/.taro/weapp/prebundle/chunk-VCL4GLTP.js");
/* harmony import */ var _chunk_MVM43PZZ_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-MVM43PZZ.js */ "./node_modules/.taro/weapp/prebundle/chunk-MVM43PZZ.js");
/* harmony import */ var _chunk_YI4HODS4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-YI4HODS4.js */ "./node_modules/.taro/weapp/prebundle/chunk-YI4HODS4.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpreadProps(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}






// entry:mini-ui
(0,_chunk_YI4HODS4_js__WEBPACK_IMPORTED_MODULE_5__.init_define_process_env)();
// node_modules/mini-ui/lib/index.js
(0,_chunk_YI4HODS4_js__WEBPACK_IMPORTED_MODULE_5__.init_define_process_env)();
var import_vue = (0,_chunk_YI4HODS4_js__WEBPACK_IMPORTED_MODULE_5__.__toESM)((0,_chunk_I7JVLPJC_js__WEBPACK_IMPORTED_MODULE_2__.require_vue)());
var import_taro = (0,_chunk_YI4HODS4_js__WEBPACK_IMPORTED_MODULE_5__.__toESM)((0,_chunk_4BR5KQZZ_js__WEBPACK_IMPORTED_MODULE_0__.require_taro)());
var execSelectQuery = (selectQuery, interval = 100, timeout = 3e3)=>{
    const _startTime = Date.now();
    return new Promise((resolve, reject)=>{
        const func = ()=>{
            selectQuery.exec((res)=>{
                const result = res[0];
                if (Date.now() - _startTime > timeout) {
                    reject(new Error("query time out"));
                } else if (result === null || Array.isArray(result) && result.length === 0) {
                    setTimeout(func, interval);
                } else {
                    resolve(result);
                }
            });
        };
        func();
    });
};
var getSizeToPx = (size)=>{
    if (String(size).startsWith("0")) return 0;
    if (typeof size === "number" || /^\d+$/.test(size)) {
        return `${size}px`;
    }
    return size;
};
var _hoisted_1$2 = [
    "id"
];
var _hoisted_2$2 = [
    "onLongpress"
];
var _sfc_main$2 = (0, import_vue.defineComponent)({
    props: {
        listData: null,
        id: {
            default: "mini-drag"
        },
        columns: {
            default: 3
        },
        itemHeight: {
            default: 124
        },
        top: {
            default: 0
        },
        bottom: {
            default: 0
        },
        vibrate: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "change",
        "update:listData",
        "scroll",
        "dragstart",
        "dragend"
    ],
    setup (__props, { emit  }) {
        const props = __props;
        const state = (0, import_vue.reactive)({
            selected: -1,
            listData: [],
            translateX: 0,
            translateY: 0
        });
        const _baseData = {
            current: -1,
            distanceX: 0,
            distanceY: 0,
            identifier: -1,
            itemHeight: 0,
            itemWidth: 0,
            containerLeft: 0,
            containerTop: 0,
            isDragging: false,
            previousMove: "",
            windowHeight: 600
        };
        const wrapHeight = (0, import_vue.computed)(()=>Math.ceil(props.listData.length / props.columns) * props.itemHeight);
        const getOffsetX = (index2)=>index2 % props.columns;
        const getOffsetY = (index2)=>Math.floor(index2 / props.columns);
        const getIndex = (x, y)=>x + props.columns * y;
        const sort = (sourceIndex, targetIndex)=>{
            const renderPositon = (list)=>{
                const listData = list.map((item)=>{
                    item.tranX = `${getOffsetX(item.sortIndex) * 100}%`;
                    item.tranY = `${getOffsetY(item.sortIndex) * 100}%`;
                    return item;
                });
                state.listData = listData;
            };
            const excludeFixed = (sortKey, reversed)=>{
                if (state.listData[sortKey].fixed) {
                    reversed ? --sortKey : ++sortKey;
                    return excludeFixed(sortKey, reversed);
                }
                return sortKey;
            };
            const move = `${sourceIndex}-${targetIndex}`;
            if (move === _baseData.previousMove) return;
            _baseData.previousMove = move;
            if (sourceIndex < targetIndex) {
                const list = state.listData.map((item)=>{
                    if (item.fixed) return item;
                    if (item.sortIndex > sourceIndex && item.sortIndex <= targetIndex) {
                        item.sortIndex = excludeFixed(item.sortIndex - 1, true);
                    } else if (item.sortIndex === sourceIndex) {
                        item.sortIndex = targetIndex;
                    }
                    return item;
                });
                renderPositon(list);
            } else if (sourceIndex > targetIndex) {
                const list1 = state.listData.map((item)=>{
                    if (item.fixed) return item;
                    if (item.sortIndex >= targetIndex && item.sortIndex < sourceIndex) {
                        item.sortIndex = excludeFixed(item.sortIndex + 1, false);
                    } else if (item.sortIndex === sourceIndex) {
                        item.sortIndex = targetIndex;
                    }
                    return item;
                });
                renderPositon(list1);
            }
        };
        const onLongPress = (event, originIndex)=>{
            const iTouch = event.touches[0];
            if (!iTouch) return;
            const realIndex = state.listData[originIndex].sortIndex;
            if (state.listData[originIndex].fixed) return;
            if (_baseData.isDragging) return;
            _baseData.isDragging = true;
            _baseData.current = originIndex;
            state.selected = realIndex;
            const offsetX = getOffsetX(realIndex) * _baseData.itemWidth;
            const offsetY = getOffsetY(realIndex) * _baseData.itemHeight;
            _baseData.distanceX = iTouch.pageX - _baseData.containerLeft - offsetX;
            _baseData.distanceY = iTouch.pageY - _baseData.containerTop - offsetY;
            _baseData.identifier = iTouch.identifier;
            state.translateX = props.columns === 1 ? 0 : offsetX;
            state.translateY = offsetY;
            if (props.vibrate) (0, import_taro.vibrateShort)({
                type: "light"
            });
            emit("dragstart", event);
        };
        const onTouchMove = (event)=>{
            event.stopPropagation();
            event.preventDefault();
            if (!_baseData.isDragging) return;
            const iTouch = event.touches[0];
            if (!iTouch) return;
            if (_baseData.identifier !== iTouch.identifier) return;
            if (iTouch.clientY > _baseData.windowHeight - _baseData.itemHeight - props.bottom) {
                emit("scroll", iTouch.pageY + _baseData.itemHeight - (_baseData.windowHeight - props.bottom));
            } else if (iTouch.clientY < _baseData.itemHeight + props.top) {
                emit("scroll", iTouch.pageY - _baseData.itemHeight - props.top);
            }
            const tranX = props.columns === 1 ? 0 : iTouch.pageX - _baseData.containerLeft - _baseData.distanceX;
            const tranY = iTouch.pageY - _baseData.containerTop - _baseData.distanceY;
            state.translateX = tranX;
            state.translateY = tranY;
            const currentItem = state.listData[_baseData.current];
            const sourceIndex = currentItem.sortIndex;
            const curX = Math.round(tranX / _baseData.itemWidth);
            const curY = Math.round(tranY / _baseData.itemHeight);
            const targetIndex = getIndex(curX, curY);
            const targetItem = state.listData[targetIndex];
            if (targetItem && targetItem.fixed) return;
            if (targetIndex > -1 && targetIndex < state.listData.length) {
                sort(sourceIndex, targetIndex);
            }
        };
        const reset = ()=>{
            _baseData.previousMove = "";
            _baseData.isDragging = false;
            _baseData.current = -1;
            state.selected = -1;
        };
        const onTouchEnd = (event)=>{
            emit("dragend", event);
            reset();
            const hasChanged = state.listData.some((v)=>v.index !== v.sortIndex);
            if (hasChanged) {
                const listData = state.listData.map((item)=>_objectSpreadProps(_objectSpread({}, item), {
                        index: item.sortIndex
                    }));
                state.listData = [
                    ...listData
                ];
                emit("update:listData", listData.map((v)=>_objectSpreadProps(_objectSpread({}, v.data), {
                        sort: v.index
                    })));
                emit("change", listData.sort((a, b)=>a.index - b.index).map((i)=>_objectSpread({}, i.data)));
            }
        };
        const render = (init)=>{
            if (init !== "init") {
                reset();
            }
            state.listData = (props.listData || []).map((data, index2)=>({
                    data,
                    fixed: data.fixed || false,
                    index: index2,
                    sortIndex: index2,
                    tranX: `${getOffsetX(index2) * 100}%`,
                    tranY: `${getOffsetY(index2) * 100}%`
                }));
            setTimeout(/*#__PURE__*/ _asyncToGenerator(function*() {
                const [container, item] = yield Promise.all([
                    execSelectQuery((0, import_taro.createSelectorQuery)().select(`#${props.id}`).boundingClientRect()),
                    execSelectQuery((0, import_taro.createSelectorQuery)().select(`#${props.id} .mini-drag-item`).boundingClientRect())
                ]);
                _baseData.itemWidth = item.width;
                _baseData.itemHeight = item.height;
                _baseData.containerLeft = container.left;
                _baseData.containerTop = container.top;
            }), 100);
        };
        (0, import_taro.useReady)(()=>{
            render("init");
            _baseData.windowHeight = (0, import_taro.getSystemInfoSync)().windowHeight;
        });
        const isEqualListData = (l1, l2)=>{
            const isEqual = (a, b)=>{
                if (Array.isArray(a) && Array.isArray(b)) {
                    return a.length === b.length ? a.every((item, index2)=>isEqual(item, b[index2])) : false;
                }
                if (typeof a === "object" && typeof b === "object") {
                    return Object.keys(a).length === Object.keys(b).length ? Object.keys(a).every((key)=>isEqual(a[key], b[key])) : false;
                }
                return Object.is(a, b);
            };
            if (l1.length !== l2.length) return false;
            return l1.every((item, index2)=>{
                const { sort: _sort1  } = item, item1 = _objectWithoutProperties(item, [
                    "sort"
                ]);
                const _l2_index2 = l2[index2], { sort: _srot2  } = _l2_index2, item2 = _objectWithoutProperties(_l2_index2, [
                    "sort"
                ]);
                return isEqual(item1, item2);
            });
        };
        (0, import_vue.watch)(()=>props.itemHeight, render);
        (0, import_vue.watch)(()=>props.columns, render);
        let _previousListData = [
            ...props.listData
        ];
        (0, import_vue.watch)(()=>props.listData, (nextListData)=>{
            if (!isEqualListData(nextListData, _previousListData)) {
                render();
            }
            _previousListData = [
                ...nextListData
            ];
        }, {
            deep: true
        });
        return (_ctx, _cache)=>{
            return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("view", {
                id: props.id,
                class: "mini-drag",
                style: (0, import_vue.normalizeStyle)({
                    height: (0, import_vue.unref)(import_taro.pxTransform)((0, import_vue.unref)(wrapHeight))
                })
            }, [
                (0, import_vue.renderSlot)(_ctx.$slots, "before"),
                ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)((0, import_vue.unref)(state).listData, (item, index2)=>{
                    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("view", {
                        key: index2,
                        class: (0, import_vue.normalizeClass)({
                            "mini-drag-item": true,
                            "mini-drag-item__upper": item.index === (0, import_vue.unref)(state).selected,
                            "mini-drag-item__transition": item.index !== (0, import_vue.unref)(state).selected
                        }),
                        style: (0, import_vue.normalizeStyle)({
                            width: `${100 / props.columns}%`,
                            height: (0, import_vue.unref)(import_taro.pxTransform)(props.itemHeight),
                            transform: item.index === (0, import_vue.unref)(state).selected ? `translateX(${(0, import_vue.unref)(state).translateX}px) translateY(${(0, import_vue.unref)(state).translateY}px)` : `translateX(${item.tranX}) translateY(${item.tranY})`
                        }),
                        onLongpress: (e)=>onLongPress(e, index2),
                        onTouchmove: onTouchMove,
                        onTouchend: onTouchEnd
                    }, [
                        (0, import_vue.renderSlot)(_ctx.$slots, "item", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)(item.data)))
                    ], 46, _hoisted_2$2);
                }), 128)),
                (0, import_vue.renderSlot)(_ctx.$slots, "after")
            ], 12, _hoisted_1$2);
        };
    }
});
var _hoisted_1$1 = {
    class: "tu-tabs"
};
var _hoisted_2$1 = {
    class: "tu-tabs__header"
};
var _hoisted_3$1 = [
    "onTap"
];
var _hoisted_4$1 = {
    class: "tu-tabs__item-text"
};
var _sfc_main$1 = (0, import_vue.defineComponent)({
    props: {
        tabList: null,
        modelValue: null,
        scrollable: {
            type: Boolean,
            default: false
        },
        id: {
            default: "tu-tabs"
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { emit  }) {
        const props = __props;
        let _scrollWidth = 375;
        let _tabItems = [];
        let _rerenderList = false;
        const state = (0, import_vue.reactive)({
            lineWidth: 0,
            lineTranX: 0,
            scrollLeft: 0,
            firstInit: true
        });
        const handleClick = function() {
            var _ref = _asyncToGenerator(function*(index2) {
                const targetTab = props.tabList[index2];
                if (targetTab.disabled) return;
                if (typeof targetTab.validate === "function") {
                    const isValid = yield targetTab.validate(index2);
                    if (!isValid) return;
                }
                emit("update:modelValue", index2);
            });
            return function handleClick(index2) {
                return _ref.apply(this, arguments);
            };
        }();
        const getLayout = ()=>{
            const item = _tabItems[props.modelValue];
            if (!item) return;
            state.lineWidth = item.width;
            state.lineTranX = item.left;
            if (props.scrollable) {
                if (_rerenderList) {
                    state.scrollLeft = state.scrollLeft + 1e-3;
                    _rerenderList = false;
                } else {
                    state.scrollLeft = Math.max(item.left - (_scrollWidth - item.width) / 2, 0);
                }
            }
        };
        const init = ()=>{
            if (!props.tabList || props.tabList.length === 0) return;
            Promise.all([
                execSelectQuery((0, import_taro.createSelectorQuery)().select(`#${props.id}`).boundingClientRect()),
                execSelectQuery((0, import_taro.createSelectorQuery)().selectAll(`#${props.id} .tu-tabs__item-text`).boundingClientRect())
            ]).then(([container, items])=>{
                _scrollWidth = container.width;
                if (_rerenderList) {
                    const previousFirstItem = _tabItems[0];
                    if (!previousFirstItem) {
                        _tabItems = items;
                        _rerenderList = false;
                    } else {
                        const distanceLeft = items[0].left - previousFirstItem.left;
                        _tabItems = items.map((v)=>_objectSpreadProps(_objectSpread({}, v), {
                                left: v.left - distanceLeft
                            }));
                    }
                } else {
                    _tabItems = items;
                }
                getLayout();
                if (state.firstInit) {
                    setTimeout(()=>state.firstInit = false, 300);
                }
            });
        };
        const tabListChange = ()=>{
            _rerenderList = true;
            setTimeout(init, Math.min(props.tabList.length * 2 + 16, 300));
        };
        (0, import_taro.useReady)(init);
        (0, import_vue.watch)(()=>props.modelValue, getLayout);
        (0, import_vue.watch)(()=>props.tabList, tabListChange, {
            deep: true
        });
        return (_ctx, _cache)=>{
            const _component_scroll_view = (0, import_vue.resolveComponent)("scroll-view");
            return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("view", _hoisted_1$1, [
                (0, import_vue.createVNode)(_component_scroll_view, {
                    id: props.id,
                    class: (0, import_vue.normalizeClass)({
                        "tu-tabs__scroll-view": true,
                        "tu-tabs__scrollable": props.scrollable
                    }),
                    "scroll-y": false,
                    "scroll-x": props.scrollable,
                    "scroll-with-animation": props.scrollable,
                    "scroll-animation-duration": 300,
                    "scroll-left": (0, import_vue.unref)(state).scrollLeft
                }, {
                    default: (0, import_vue.withCtx)(()=>[
                            (0, import_vue.createElementVNode)("view", _hoisted_2$1, [
                                ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(props.tabList, (item, index2)=>{
                                    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("view", {
                                        key: index2,
                                        class: (0, import_vue.normalizeClass)({
                                            "tu-tabs__item": true,
                                            "tu-tabs__item--active": props.modelValue === index2
                                        }),
                                        onTap: ()=>handleClick(index2)
                                    }, [
                                        (0, import_vue.createElementVNode)("view", _hoisted_4$1, (0, import_vue.toDisplayString)(item.title), 1)
                                    ], 42, _hoisted_3$1);
                                }), 128)),
                                (0, import_vue.createElementVNode)("view", {
                                    class: "tu-tabs__item-underline",
                                    style: (0, import_vue.normalizeStyle)({
                                        width: `${(0, import_vue.unref)(state).lineWidth}px`,
                                        transform: `translateX(${(0, import_vue.unref)(state).lineTranX}px)`,
                                        transition: `${(0, import_vue.unref)(state).firstInit ? "unset" : ""}`
                                    })
                                }, null, 4)
                            ])
                        ]),
                    _: 1
                }, 8, [
                    "id",
                    "class",
                    "scroll-x",
                    "scroll-with-animation",
                    "scroll-left"
                ])
            ]);
        };
    }
});
var LoadingIcon = ()=>(0, import_vue.createVNode)("view", {
        "class": "tu-loading"
    }, [
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null),
        (0, import_vue.createVNode)("view", {
            "class": "tu-loading__item"
        }, null)
    ]);
var ArrowIcon = ()=>(0, import_vue.createVNode)("view", {
        "class": "tu-arrow"
    }, [
        (0, import_vue.createVNode)("view", {
            "class": "tu-arrow__line"
        }, null)
    ]);
var _hoisted_1 = (0, import_vue.createElementVNode)("text", {
    class: "tu-scroll__refresher-text"
}, "\u52A0\u8F7D\u4E2D...", -1);
var _hoisted_2 = {
    class: "tu-scroll__refresher-text"
};
var _hoisted_3 = {
    class: "tu-scroll__loadmore"
};
var _hoisted_4 = (0, import_vue.createElementVNode)("text", {
    class: "tu-scroll__refresher-text"
}, "\u52A0\u8F7D\u4E2D...", -1);
var _sfc_main = (0, import_vue.defineComponent)({
    props: {
        id: {
            default: "tu-scroll"
        },
        threshold: {
            default: 60
        },
        refresherEnabled: {
            type: Boolean,
            default: true
        },
        refresherBackground: {
            default: "#eeeeee"
        },
        refresherThreshold: {
            default: 80
        },
        refresh: {
            type: Function,
            default: ()=>new Promise((resolve)=>{
                    setTimeout(resolve, 1e3);
                })
        },
        loadmore: {
            type: Function,
            default: ()=>new Promise((resolve)=>{
                    setTimeout(resolve, 1e3);
                })
        },
        showSuccess: {
            type: Boolean,
            default: true
        },
        successText: {
            default: "\u5237\u65B0\u6210\u529F"
        }
    },
    emits: [
        "scroll"
    ],
    setup (__props, { expose , emit  }) {
        const props = __props;
        const state = (0, import_vue.reactive)({
            refreshStatus: 0,
            isMoreLoading: false,
            flush: false
        });
        let _scrollHeight = 0;
        let _timer = null;
        const dummyRequest = (ms)=>new Promise((resolve)=>{
                setTimeout(resolve, typeof ms === "number" ? ms : 1e3);
            });
        const onRefresherPulling = (e)=>{
            if (state.refreshStatus > 1) return;
            const status = e.detail.dy > props.refresherThreshold ? 1 : 0;
            if (state.refreshStatus !== status) {
                state.refreshStatus = status;
            }
        };
        const onScrollToLower = function() {
            var _ref = _asyncToGenerator(function*() {
                if (state.isMoreLoading) return;
                state.isMoreLoading = true;
                yield Promise.all([
                    props.loadmore(),
                    dummyRequest(1e3)
                ]);
                state.isMoreLoading = false;
            });
            return function onScrollToLower() {
                return _ref.apply(this, arguments);
            };
        }();
        const reset = ()=>{
            state.refreshStatus = 0;
        };
        const onRefresherRefresh = function() {
            var _ref = _asyncToGenerator(function*(e) {
                if (state.refreshStatus === 2) return;
                if (!e || e.type !== "refresherrefresh") {
                    state.flush = true;
                }
                state.refreshStatus = 2;
                yield Promise.all([
                    props.refresh(),
                    dummyRequest(1e3)
                ]);
                state.flush = false;
                state.refreshStatus = 3;
                clearTimeout(_timer);
                if (props.showSuccess) {
                    _timer = setTimeout(()=>{
                        state.refreshStatus = 4;
                        _timer = setTimeout(()=>{
                            state.refreshStatus = 5;
                            _timer = setTimeout(reset, 360);
                        }, 1500);
                    }, 20);
                } else {
                    _timer = setTimeout(reset, 100);
                }
            });
            return function onRefresherRefresh(e) {
                return _ref.apply(this, arguments);
            };
        }();
        const onRefresherRestore = ()=>{
            console.log("onRefresherRestore \u590D\u4F4D");
        };
        const onRefresherAbort = ()=>{
            console.log("onRefresherAbort \u7EC8\u6B62");
        };
        const tryScrollToLower = ({ detail: { scrollTop , scrollHeight  }  })=>{
            if (_scrollHeight === 0) return;
            const largerThreshold = _scrollHeight * 3 / 4;
            const originScrollHeight = scrollTop + _scrollHeight + props.threshold;
            const largerScrollHeight = scrollTop + _scrollHeight + largerThreshold;
            if (largerScrollHeight >= scrollHeight && originScrollHeight < scrollHeight) {
                onScrollToLower();
            }
        };
        const onScroll = (e)=>{
            emit("scroll", e);
            tryScrollToLower(e);
        };
        expose({
            refresh: onRefresherRefresh
        });
        (0, import_taro.useReady)(()=>{
            execSelectQuery((0, import_taro.createSelectorQuery)().select(`#${props.id}`).boundingClientRect()).then((res)=>{
                _scrollHeight = res.height;
            });
        });
        return (_ctx, _cache)=>{
            const _component_block = (0, import_vue.resolveComponent)("block");
            const _component_scroll_view = (0, import_vue.resolveComponent)("scroll-view");
            return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_scroll_view, {
                id: props.id,
                class: "tu-scroll",
                "refresher-default-style": "none",
                "scroll-x": false,
                "scroll-y": true,
                "lower-threshold": props.threshold,
                "scroll-with-animation": "",
                "enable-flex": "",
                "refresher-enabled": props.refresherEnabled,
                "refresher-threshold": props.refresherThreshold,
                "refresher-background": props.refresherBackground,
                "refresher-triggered": (0, import_vue.unref)(state).refreshStatus === 2,
                onScrolltolower: onScrollToLower,
                onRefresherpulling: onRefresherPulling,
                onRefresherrefresh: onRefresherRefresh,
                onRefresherrestore: onRefresherRestore,
                onRefresherabort: onRefresherAbort,
                onScroll
            }, {
                default: (0, import_vue.withCtx)(()=>[
                        (0, import_vue.createElementVNode)("view", {
                            class: "tu-scroll__refresher",
                            style: (0, import_vue.normalizeStyle)({
                                height: props.refresherThreshold + "px",
                                top: (0, import_vue.unref)(state).flush ? 0 : -props.refresherThreshold + "px"
                            })
                        }, [
                            (0, import_vue.unref)(state).refreshStatus === 2 ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_block, {
                                key: 0
                            }, {
                                default: (0, import_vue.withCtx)(()=>[
                                        (0, import_vue.createVNode)((0, import_vue.unref)(LoadingIcon)),
                                        _hoisted_1
                                    ]),
                                _: 1
                            })) : (0, import_vue.unref)(state).refreshStatus < 2 ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_block, {
                                key: 1
                            }, {
                                default: (0, import_vue.withCtx)(()=>[
                                        (0, import_vue.createVNode)((0, import_vue.unref)(ArrowIcon), {
                                            class: (0, import_vue.normalizeClass)({
                                                "rotate": (0, import_vue.unref)(state).refreshStatus === 1
                                            })
                                        }, null, 8, [
                                            "class"
                                        ]),
                                        (0, import_vue.createElementVNode)("text", _hoisted_2, (0, import_vue.toDisplayString)((0, import_vue.unref)(state).refreshStatus === 1 ? "\u91CA\u653E\u5237\u65B0" : "\u4E0B\u62C9\u5237\u65B0"), 1)
                                    ]),
                                _: 1
                            })) : (0, import_vue.createCommentVNode)("", true)
                        ], 4),
                        props.showSuccess && (0, import_vue.unref)(state).refreshStatus >= 3 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("view", {
                            key: 0,
                            class: (0, import_vue.normalizeClass)({
                                "tu-scroll__success": true,
                                "tu-scroll__success-show": (0, import_vue.unref)(state).refreshStatus >= 4,
                                "tu-scroll__success-hide": (0, import_vue.unref)(state).refreshStatus === 5
                            }),
                            style: (0, import_vue.normalizeStyle)({
                                height: props.refresherThreshold + "px"
                            })
                        }, [
                            (0, import_vue.createElementVNode)("view", {
                                class: (0, import_vue.normalizeClass)({
                                    "tu-scroll__success-bar": true,
                                    "tu-scroll__success-bar-show": (0, import_vue.unref)(state).refreshStatus >= 4
                                })
                            }, (0, import_vue.toDisplayString)(props.successText), 3)
                        ], 6)) : (0, import_vue.createCommentVNode)("", true),
                        (0, import_vue.renderSlot)(_ctx.$slots, "default"),
                        (0, import_vue.withDirectives)((0, import_vue.createElementVNode)("view", _hoisted_3, [
                            (0, import_vue.createVNode)((0, import_vue.unref)(LoadingIcon)),
                            _hoisted_4
                        ], 512), [
                            [
                                import_vue.vShow,
                                (0, import_vue.unref)(state).isMoreLoading
                            ]
                        ])
                    ]),
                _: 3
            }, 8, [
                "id",
                "lower-threshold",
                "refresher-enabled",
                "refresher-threshold",
                "refresher-background",
                "refresher-triggered"
            ]);
        };
    }
});
var index = (0, import_vue.defineComponent)({
    props: {
        title: {
            type: String,
            default: ""
        },
        color: {
            type: String,
            default: "#222222"
        },
        backgroundColor: {
            type: String,
            default: "#FFFFFF"
        },
        fixed: {
            type: Boolean,
            default: true
        },
        height: {
            type: [
                String,
                Number
            ],
            default: 44
        },
        goback: Function,
        hideBack: {
            type: Boolean,
            default: false
        }
    },
    setup (props, { slots  }) {
        const { statusBarHeight  } = import_taro.default.getSystemInfoSync();
        const fixedClass = props.fixed ? "mini-navbar__fixed" : "";
        const statusBarStyle = {
            height: `${statusBarHeight}px`
        };
        const height = getSizeToPx(props.height);
        const handleBack = (e)=>{
            if (typeof props.goback === "function") {
                props.goback(e);
            } else {
                import_taro.default.navigateBack();
            }
        };
        return ()=>(0, import_vue.createVNode)("view", {
                "className": "mini-navbar"
            }, [
                (0, import_vue.createVNode)("view", {
                    "className": fixedClass,
                    "style": {
                        backgroundColor: props.backgroundColor
                    }
                }, [
                    (0, import_vue.createVNode)("view", {
                        "style": statusBarStyle
                    }, null),
                    height !== 0 && (0, import_vue.createVNode)("view", {
                        "className": "mini-navbar__header",
                        "style": {
                            height,
                            backgroundColor: props.backgroundColor
                        }
                    }, [
                        !props.hideBack && (0, import_vue.createVNode)("view", {
                            "className": "mini-navbar__header-left"
                        }, [
                            !slots.left ? (0, import_vue.createVNode)("view", {
                                "className": "mini-navbar__goback",
                                "onTouchstart": handleBack
                            }, [
                                (0, import_vue.createVNode)("image", {
                                    "src": "https://panshi-on.oss-cn-hangzhou.aliyuncs.com/yunxiaoding-mini/system/assets/images/JFEMBCAF-1666323574944icon-back-black.png",
                                    "className": "mini-navbar__icon"
                                }, null)
                            ]) : slots.left()
                        ]),
                        (0, import_vue.createVNode)("view", {
                            "className": "mini-navbar__header-wrap"
                        }, [
                            !slots.title ? (0, import_vue.createVNode)("text", {
                                "style": {
                                    color: props.color
                                }
                            }, [
                                props.title
                            ]) : slots.title()
                        ])
                    ])
                ]),
                (0, import_vue.createVNode)("view", {
                    "className": "mini-navbar__placeholder"
                }, [
                    (0, import_vue.createVNode)("view", {
                        "style": statusBarStyle
                    }, null),
                    (0, import_vue.createVNode)("view", {
                        "style": {
                            height
                        }
                    }, null)
                ])
            ]);
    }
});



/***/ })

}]);